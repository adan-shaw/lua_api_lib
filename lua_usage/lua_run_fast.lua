--[[
1.使用local 来取代核心库函数, 即便是像math, os 的函数, 你也需要用local 来拆分, 原因并不是内存重用的问题, 是解析编译问题!!
我们都知道lua 是一个脚本机, 边解析边运行, 对于math 库中的所有函数, lua 机遇到这样的语句, 
肯定就会先解析再运行, 但是正因为如此, 你在一个for 里面不停调用math 库中的函数??
这就肯定会触发n 次循环解析, 这时候, local 指针就起作用了...
如:
local sin = math.sin;
for i=1, 100000 do
  sin(i);
end
这样就可以避免解析器进入循环里面, 每次运行都进行解析, 代码这样运行比裸跑math.sin 解析快30% !!

尽管和其他语言的解析编译器比, Lua解析编译器的效率非常高, 然解析编译是件繁重的任务...
因此, 你应该尽可能避免在程序中解析编译(例如,函数loadstring)
除非你必须运行动态的代码, 像通过终端输入的代码, 你很少需要编译动态代码


2.lua table 的哈希特性, 引发的性能问题...
虽然lua 极力隐藏实现细节不暴露给用户, 但是实际上, 其设计还是离不开根本的, 
例如: table 的两种形态: 数组和哈希...
我们假设local t = {};--这是一个空table, 只是一个指针...
但是当我们往里面插入值的时候, 其哈希特性就开始暴露了...
当lua在表中插入一个key, 并且哈希数组已满的时候, lua会重新哈希...
重新哈希第一步是决定新数组部分和新哈希部分的大小, 因此:
1.lua遍历所有元素, 并对其计数, 分类, 然后选择与<数组的最大尺寸>相近的 2的幂次方, 作为新容器的长度
2.根据新长度重新哈希, 以便容纳新元素...
虽然这样的增长方式是很快, 一百万个元素的表只需要20次...但是最好还是先初始化表大小, 再填入值...
注意: 初始化表大小并不是指:
for i=1,16 do xtable[i] = 0; end
而是:
local xtable = {0,0,0,0}--这样有一定基数, 对于普通表使用有一定好处,
local xtable = {nil,nil,nil,nil}--如果对数字敏感, 可以这样初始化
local xtable = {true,true,true,true}--或者这样

这样就决定了, table 重用永远比table = nil; 然后重新建一个table 要效率高
如果table 整个表都被清空(key=nil), 那么其哈希域是不会被释放的,
当table 中仍然有值=nil 可用, 插入时都不会重新申请哈希域

关于table 迭代器遍历:
for k in pairs(t) do end--迭代器的效率可以, 但是仍然不如[1] 下标快
next(t)--这是table 里面效率最低的操作
这类非lua table 数组特性的操作, 最好直接用迭代器遍历...



3.关于字符串
不同于大多数的脚本语言, lua实现字符串的方式表现在两个重要的方面:
第一: lua中所有的字符串都是内化的, 意思是Lua对任一字符串只保留一份拷贝, 无论何时出现新字符串, 
Lua会检测这个字符串是否已经存在备份, 如果是, 重用拷贝...
内化string使得像string的比较和表索引操作非常快, 但是字符串的创建会慢...

第二: lua中的变量从不持有字符串, 仅是引用他们, 这种实现方式加快了几个字符串的操作...


4.关于协程:
如果你需要用到协程, 并且可能会面对频繁创建和销毁协程的时候, 你不如挟持协程, 通过传入函数体来执行协程,
这样的效率会更高...如:
co = coroutine.create(
  function (f)
    while f do
　　　   f = coroutine.yield(f())
　　　end
　　end
end)
对于: collectgarbage("stop") 你也不能经常用...还要, 最好的你还是用指针带过来用

//*******************************************
//题外话: tolua++ 可以实现快速实现cpp lua so 库
//*******************************************
tolua++ 本质: 只是减少了工作量, 对于lua 通信栈压栈, lua table, lua 系统函数math,os 等调用,
tolua++ 是没办法实现的, 但是tolua 可以很好地解决函数打包翻译, 普通的double=number 形参输入问题


]]
